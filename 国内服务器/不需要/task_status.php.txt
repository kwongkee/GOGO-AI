<?php
// 严格错误报告
error_reporting(E_ALL);
ini_set('display_errors', 0);
ini_set('log_errors', 1);
ini_set('error_log', '/var/log/multimodal_rag/php_errors.log');

// 安全头设置
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('X-XSS-Protection: 1; mode=block');
header('Content-Type: application/json; charset=utf-8');

class TaskStatusQuery {
    private $redis;
    private $db_connection;
    
    public function __construct() {
        $this->initializeRedis();
        $this->initializeDatabase();
    }
    
    private function initializeRedis() {
        try {
            $this->redis = new Redis();
            $this->redis->connect('127.0.0.1', 6379, 5);
            $this->redis->auth('你的Redis密码');
            $this->redis->ping();
        } catch (Exception $e) {
            $this->sendErrorResponse("缓存服务不可用", 503);
        }
    }
    
    private function initializeDatabase() {
        try {
            $this->db_connection = new PDO(
                'mysql:host=localhost;dbname=upload_system;charset=utf8mb4',
                'username',
                'password',
                [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                    PDO::ATTR_EMULATE_PREPARES => false
                ]
            );
        } catch (PDOException $e) {
            // 数据库不可用，但Redis仍可用
            error_log("数据库连接失败: " . $e->getMessage());
        }
    }
    
    public function handleStatusQuery() {
        try {
            // 验证请求方法
            if ($_SERVER['REQUEST_METHOD'] !== 'GET') {
                $this->sendErrorResponse('只支持GET请求', 405);
            }
            
            // 获取和验证任务ID
            $task_id = $this->validateAndGetTaskId();
            
            // 查询任务状态
            $task_status = $this->getTaskStatus($task_id);
            
            // 返回统一格式的响应
            $this->sendJsonResponse([
                'success' => true,
                'task_id' => $task_id,
                'status' => $task_status,
                'timestamp' => date('c')
            ]);
            
        } catch (Exception $e) {
            error_log("任务状态查询异常: " . $e->getMessage());
            $this->sendErrorResponse('服务器内部错误', 500);
        }
    }
    
    private function validateAndGetTaskId() {
        // 从GET参数获取任务ID
        $task_id = $_GET['task_id'] ?? '';
        
        if (empty($task_id)) {
            $this->sendErrorResponse('任务ID不能为空', 400);
        }
        
        // 验证任务ID格式
        if (!preg_match('/^task_[a-f0-9_]+$/', $task_id)) {
            $this->sendErrorResponse('任务ID格式无效', 400);
        }
        
        // 防止SQL注入和非法字符
        $task_id = filter_var($task_id, FILTER_SANITIZE_STRING);
        $task_id = substr($task_id, 0, 50); // 限制长度
        
        return $task_id;
    }
    
    private function getTaskStatus($task_id) {
        // 先从Redis获取任务状态
        $task_data = $this->redis->hGetAll("task:{$task_id}");
        
        if (empty($task_data)) {
            // 如果Redis中没有，尝试从数据库获取
            $task_data = $this->getTaskStatusFromDatabase($task_id);
            
            if (empty($task_data)) {
                $this->sendErrorResponse('任务不存在或已过期', 404);
            }
            
            // 将数据库数据缓存到Redis
            $this->cacheTaskStatus($task_id, $task_data);
        }
        
        return $this->formatTaskStatus($task_data);
    }
    
    private function getTaskStatusFromDatabase($task_id) {
        if (!$this->db_connection) {
            return null;
        }
        
        try {
            $stmt = $this->db_connection->prepare("
                SELECT t.task_id, t.status, t.progress, t.create_time, 
                       t.update_time, t.error_message, t.file_count,
                       COUNT(f.id) as processed_files
                FROM tasks t
                LEFT JOIN processed_files f ON t.task_id = f.task_id 
                WHERE t.task_id = ?
                GROUP BY t.task_id
            ");
            
            $stmt->execute([$task_id]);
            $task_data = $stmt->fetch();
            
            if ($task_data) {
                // 转换为与Redis相同的格式
                return [
                    'task_id' => $task_data['task_id'],
                    'status' => $task_data['status'],
                    'progress' => $task_data['progress'],
                    'create_time' => $task_data['create_time'],
                    'update_time' => $task_data['update_time'],
                    'error_message' => $task_data['error_message'] ?? '',
                    'file_count' => $task_data['file_count'],
                    'processed_files' => $task_data['processed_files']
                ];
            }
        } catch (PDOException $e) {
            error_log("数据库查询失败: " . $e->getMessage());
        }
        
        return null;
    }
    
    private function cacheTaskStatus($task_id, $task_data) {
        try {
            $this->redis->hMSet("task:{$task_id}", $task_data);
            $this->redis->expire("task:{$task_id}", 3600); // 缓存1小时
        } catch (Exception $e) {
            error_log("任务状态缓存失败: " . $e->getMessage());
        }
    }
    
    private function formatTaskStatus($task_data) {
        $base_status = [
            'status' => $task_data['status'] ?? 'unknown',
            'progress' => intval($task_data['progress'] ?? 0),
            'create_time' => $task_data['create_time'] ?? '',
            'update_time' => $task_data['update_time'] ?? '',
            'file_count' => intval($task_data['file_count'] ?? 0),
            'processed_files' => intval($task_data['processed_files'] ?? 0),
	    'uploader_type' => $task_data['uploader_type'] ?? 0, // 新增字段
            'is_backend_operation' => isset($task_data['is_backend_operation']) ? 
                (bool)$task_data['is_backend_operation'] : false // 新增字段
        ];
        
        // 根据状态添加额外信息
        switch ($base_status['status']) {
            case 'processing':
                $base_status['estimated_remaining'] = $this->calculateRemainingTime($task_data);
                $base_status['current_file'] = $task_data['current_file'] ?? '';
                break;
                
            case 'completed':
                $base_status['completion_time'] = $task_data['update_time'] ?? '';
                $base_status['result_url'] = $this->generateResultUrl($task_data);
                break;
                
            case 'failed':
                $base_status['error_message'] = $task_data['error_message'] ?? '';
                $base_status['error_code'] = $task_data['error_code'] ?? '';
                break;
        }
        
        return $base_status;
    }
    
    private function calculateRemainingTime($task_data) {
        if (empty($task_data['create_time']) || empty($task_data['progress'])) {
            return '未知';
        }
        
        $progress = intval($task_data['progress']);
        if ($progress <= 0) {
            return '未知';
        }
        
        $create_time = strtotime($task_data['create_time']);
        $current_time = time();
        $elapsed_time = $current_time - $create_time;
        
        if ($elapsed_time <= 0) {
            return '未知';
        }
        
        $total_estimated = ($elapsed_time * 100) / $progress;
        $remaining_seconds = $total_estimated - $elapsed_time;
        
        if ($remaining_seconds < 0) {
            return '即将完成';
        }
        
        return $this->formatDuration($remaining_seconds);
    }
    
    private function formatDuration($seconds) {
        if ($seconds < 60) {
            return "{$seconds}秒";
        } elseif ($seconds < 3600) {
            $minutes = floor($seconds / 60);
            return "{$minutes}分钟";
        } else {
            $hours = floor($seconds / 3600);
            $minutes = floor(($seconds % 3600) / 60);
            return "{$hours}小时{$minutes}分钟";
        }
    }
    
    private function generateResultUrl($task_data) {
        $task_id = $task_data['task_id'] ?? '';
        if (empty($task_id)) {
            return '';
        }
        
        return "/api/results/{$task_id}/download";
    }
    
    public function handleBatchStatusQuery() {
        try {
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                $this->sendErrorResponse('只支持POST请求', 405);
            }
            
            $input = json_decode(file_get_contents('php://input'), true);
            $task_ids = $input['task_ids'] ?? [];
            
            if (empty($task_ids) || !is_array($task_ids)) {
                $this->sendErrorResponse('任务ID列表不能为空', 400);
            }
            
            if (count($task_ids) > 50) {
                $this->sendErrorResponse('批量查询最多支持50个任务', 400);
            }
            
            $results = [];
            foreach ($task_ids as $task_id) {
                if (preg_match('/^task_[a-f0-9_]+$/', $task_id)) {
                    $task_data = $this->redis->hGetAll("task:{$task_id}");
                    $results[$task_id] = $this->formatTaskStatus($task_data);
                }
            }
            
            $this->sendJsonResponse([
                'success' => true,
                'results' => $results,
                'total_count' => count($results),
                'timestamp' => date('c')
            ]);
            
        } catch (Exception $e) {
            error_log("批量任务状态查询异常: " . $e->getMessage());
            $this->sendErrorResponse('服务器内部错误', 500);
        }
    }
    
    private function sendJsonResponse($data, $status_code = 200) {
        http_response_code($status_code);
        echo json_encode($data, JSON_UNESCAPED_UNICODE | JSON_PRETTY_PRINT);
        exit;
    }
    
    private function sendErrorResponse($message, $status_code = 400) {
        $this->sendJsonResponse([
            'success' => false,
            'error' => $message,
            'status_code' => $status_code,
            'timestamp' => date('c')
        ], $status_code);
    }
}

// 路由处理
try {
    $query = new TaskStatusQuery();
    
    // 根据请求路径决定处理方式
    $request_uri = $_SERVER['REQUEST_URI'] ?? '';
    
    if (strpos($request_uri, '/api/tasks/batch') !== false) {
        $query->handleBatchStatusQuery();
    } else {
        $query->handleStatusQuery();
    }
    
} catch (Exception $e) {
    error_log("任务状态查询处理器异常: " . $e->getMessage());
    http_response_code(500);
    echo json_encode([
        'success' => false, 
        'error' => '服务器内部错误',
        'timestamp' => date('c')
    ]);
}
?>