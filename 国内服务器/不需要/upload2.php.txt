<?php
// 引入 Predis 自动加载
require '../vendor/autoload.php';
use Predis\Client;

error_reporting(E_ALL);
ini_set('display_errors', 0);
ini_set('log_errors', 1);
ini_set('error_log', '/var/log/file_upload.log');

header('Content-Type: application/json; charset=utf-8');

class FilePathProcessor {
    private $redis;
    private $allowed_extensions;
    
    public function __construct() {
        $this->initializeRedis();
        $this->loadConfig();
    }
    
    private function initializeRedis() {
        try {
            // 使用 Predis\Client 替代 Redis 扩展
            $this->redis = new Client([
                'scheme' => 'tcp',
                'host'   => '127.0.0.1',
                'port'   => 6379,
                'timeout' => 5.0,
                // 如果有密码：'password' => '你的Redis密码',
            ]);
            
            // 测试连接
            $this->redis->ping();
            
        } catch (Exception $e) {
            error_log("Redis连接失败: " . $e->getMessage());
            $this->sendErrorResponse("Redis服务不可用", 503);
        }
    }
    
    private function loadConfig() {
        $this->allowed_extensions = ['mp3', 'mp4', 'jpg', 'png', 'jpeg', 'pdf', 'txt', 'pptx', 'docx', 'xls', 'xlsx'];
    }
    
    public function processFilePath() {
        try {
            if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
                $this->sendErrorResponse('只支持POST请求', 405);
            }
            
            // 获取参数
            $file_path = $_POST['file_path'] ? json_decode($_POST['file_path'],true): '';
            $is_user = $_POST['is_user'] ?? 0;
            $knowledge_id = $_POST['knowledge_id'] ?? 0;
            $cid = $_POST['cid'] ?? 0;
            
            if (empty($file_path)) {
                $this->sendErrorResponse('文件路径不能为空', 400);
            }
            
            // 处理文件路径（支持数组和字符串）
            $file_paths = is_array($file_path) ? $file_path : [$file_path];
            $results = [];
            
            foreach ($file_paths as $path) {
                $result = $this->processSingleFilePath($path, [
                    'is_user' => $is_user,
                    'knowledge_id' => $knowledge_id,
                    'cid' => $cid
                ]);
                $results[] = $result;
            }
            
            $success_count = count(array_filter($results, function($r) { 
                return $r['success']; 
            }));
            
            $this->sendSuccessResponse([
                'success_count' => $success_count,
                'total_files' => count($file_paths),
                'results' => $results
            ]);
            
        } catch (Exception $e) {
            error_log("文件路径处理异常: " . $e->getMessage());
            $this->sendErrorResponse('服务器内部错误', 500);
        }
    }
    
    private function processSingleFilePath($file_path, $metadata = []) {
        // 验证文件路径
        if (empty($file_path)) {
            return ['success' => false, 'error' => '文件路径为空'];
        }
        
        // 标准化路径
        if($metadata['cid']==0){
            //普通用户体验上传
            $full_path = '/www/wwwroot/ai.gogo198.net/public' . $file_path;
        }
        elseif($metadata['cid']>0){
            //商家上传知识文件
            $full_path = '/www/wwwroot/website.gogo198.net/public' . $file_path;
        }
        
        // 验证文件存在性
        if (!file_exists($full_path)) {
            return ['success' => false, 'error' => "文件不存在: {$file_path}"];
        }
        
        if (!is_readable($full_path)) {
            return ['success' => false, 'error' => "文件不可读: {$file_path}"];
        }
        
        // 验证文件扩展名
        $file_extension = strtolower(pathinfo($full_path, PATHINFO_EXTENSION));
        if (!in_array($file_extension, $this->allowed_extensions)) {
            return ['success' => false, 'error' => "不支持的文件类型: {$file_extension}"];
        }
        
        // 验证文件大小
        $file_size = filesize($full_path);
        $max_size = 100 * 1024 * 1024; // 100MB
        if ($file_size > $max_size) {
            $max_size_mb = $max_size / 1024 / 1024;
            return ['success' => false, 'error' => "文件过大，最大支持{$max_size_mb}MB"];
        }
        
        try {
            // 创建任务
            $task_id = uniqid('path_task_', true);
            
            $task_data = [
                'task_id' => $task_id,
                'file_paths' => [$full_path],
                'original_path' => $file_path,
                'metadata' => array_merge($metadata, [
                    'source' => 'backend_sync',
                    'file_size' => $file_size,
                    'file_extension' => $file_extension,
                    'process_time' => date('c')
                ]),
                'action' => 'process_existing_file'
            ];
            
            // 推送到Redis队列 - 使用 Predis 方法
            $this->redis->rpush('index_tasks', json_encode($task_data));
            $this->redis->setex("task:{$task_id}", 86400, json_encode([
                'status' => 'pending',
                'file_path' => $full_path,
                'create_time' => date('c')
            ]));
            
            return [
                'success' => true,
                'task_id' => $task_id,
                'file_path' => $file_path,
                'file_size' => $file_size,
                'message' => '文件已加入处理队列'
            ];
            
        } catch (Exception $e) {
            return [
                'success' => false,
                'error' => '队列处理失败: ' . $e->getMessage()
            ];
        }
    }
    
    private function sendSuccessResponse($data) {
        http_response_code(200);
        echo json_encode([
            'success' => true,
            'data' => $data,
            'timestamp' => date('c')
        ], JSON_UNESCAPED_UNICODE);
        exit;
    }
    
    private function sendErrorResponse($message, $status_code = 400) {
        http_response_code($status_code);
        echo json_encode([
            'success' => false,
            'error' => $message,
            'status_code' => $status_code,
            'timestamp' => date('c')
        ], JSON_UNESCAPED_UNICODE);
        exit;
    }
}

// 处理请求
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    try {
        $processor = new FilePathProcessor();
        $processor->processFilePath();
    } catch (Exception $e) {
        http_response_code(500);
        echo json_encode([
            'success' => false, 
            'error' => '处理器异常: ' . $e->getMessage(),
            'timestamp' => date('c')
        ]);
    }
} else {
    http_response_code(405);
    echo json_encode([
        'success' => false,
        'error' => '只支持POST请求',
        'timestamp' => date('c')
    ]);
}
?>